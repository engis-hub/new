import numpy as np
import pandas as pd
from numpy import sin, cos, pi

# ========= Variants =========
VARIANTS = {
    "R290": dict(
        ENFORCE_CONST=False
    ),
    "R32": dict(
        ENFORCE_CONST=True
    ),
}

# Global physicals
GAMMA        = 1.４５
P_SUCTION_MP = 1.0
h_wrap       = 34.0

# Steps
DEG_STEP_MAIN = 10.0
EPS_FIX_DEG = 0.6
EPS_ORB_DEG = 1.2

# ========= Geometry helpers =========
def u_dir(phi):  return np.array([np.cos(phi), -np.sin(phi)])
def n_perp(phi): return np.array([np.sin(phi),  np.cos(phi)])

def P_stat_center(r, t):
    return np.array([-r*(sin(t) - t*cos(t)),  r*(cos(t) + t*sin(t))])
def P_orb_center(r, E, t, phi):
    X0, Y0 = E*np.cos(phi), -E*np.sin(phi)
    return np.array([ r*(sin(t) - t*cos(t)) + X0, -r*(cos(t) + t*sin(t)) + Y0 ])

def stat_out(r, T, t):
    x = -r*(sin(t) - t*cos(t)) + (T/2.0)*cos(t)
    y =  r*(cos(t) + t*sin(t)) + (T/2.0)*sin(t)
    return x, y
def stat_in(r, T, t):
    x = -r*(sin(t) - t*cos(t)) - (T/2.0)*cos(t)
    y =  r*(cos(t) + t*sin(t)) - (T/2.0)*sin(t)
    return x, y
def orb_out_local(r, T, t):
    x =  r*(sin(t) - t*cos(t)) - (T/2.0)*cos(t)
    y = -r*(cos(t) + t*sin(t)) - (T/2.0)*sin(t)
    return x, y
def orb_in_local(r, T, t):
    x =  r*(sin(t) - t*cos(t)) + (T/2.0)*cos(t)
    y = -r*(cos(t) + t*sin(t)) + (T/2.0)*sin(t)
    return x, y
def translate_orbit(E, x, y, phi):
    return x + E*np.cos(phi), y - E*np.sin(phi)

# ========= Intersection machinery =========
def H_line_fixed_in(r, T, Rg, E, t, phi):
    n = n_perp(phi); r0 =  Rg*n
    x, y = stat_in(r,T,t);  return n[0]*(x - r0[0]) + n[1]*(y - r0[1])
def H_line_fixed_out(r, T, Rg, E, t, phi):
    n = n_perp(phi); r0 = -Rg*n
    x, y = stat_out(r,T,t); return n[0]*(x - r0[0]) + n[1]*(y - r0[1])
def H_line_orbit_out(r, T, Rg, E, t, phi):
    n = n_perp(phi); r0 =  Rg*n
    x, y = translate_orbit(E, *orb_out_local(r,T,t), phi); return n[0]*(x - r0[0]) + n[1]*(y - r0[1])
def H_line_orbit_in(r, T, Rg, E, t, phi):
    n = n_perp(phi); r0 = -Rg*n
    x, y = translate_orbit(E, *orb_in_local(r,T,t), phi);  return n[0]*(x - r0[0]) + n[1]*(y - r0[1])

def _bisect(func, a, b, args, itmax=60, tol=1e-12):
    fa, fb = func(a, *args), func(b, *args)
    if fa*fb > 0: return None
    lo, hi, flo, fhi = a, b, fa, fb
    for _ in range(itmax):
        m = 0.5*(lo + hi); fm = func(m, *args)
        if abs(fm) <= 1e-14 or (hi-lo)/2 < tol*(1+abs(m)): return m
        if flo*fm <= 0: hi, fhi = m, fm
        else:           lo, flo = m, fm
    return 0.5*(lo + hi)

def find_roots(func, args, tmin, tmax, M=20000, tol_zero=1e-9):
    ts = np.linspace(tmin, tmax, M+1)
    Hs = func(ts, *args)
    roots = []
    nz = np.where(np.abs(Hs) <= tol_zero)[0].tolist()
    for i in nz: roots.append(ts[i])
    for i in range(M):
        a, b, fa, fb = ts[i], ts[i+1], Hs[i], Hs[i+1]
        if fa*fb < 0:
            m = _bisect(func, a, b, args);  roots += ([] if m is None else [m])
        else:
            if abs(fa) < 10*tol_zero:
                left = max(tmin, a - (tmax-tmin)/M)
                m = _bisect(func, left, min(b, a+(tmax-tmin)/M), args);  roots += ([] if m is None else [m])
            if abs(fb) < 10*tol_zero:
                right = min(tmax, b + (tmax-tmin)/M)
                m = _bisect(func, max(a, b-(tmax-tmin)/M), right, args); roots += ([] if m else [])
    roots = sorted(set([float(np.round(r, 10)) for r in roots]))
    return roots

def sort_by_halfline(r, T, Rg, E, phi, side, xy_pts, ts):
    if len(ts) == 0: return [], [], []
    n = n_perp(phi); u = u_dir(phi)
    r0 = ( Rg*n if side=='L' else -Rg*n )
    pts = np.array(xy_pts)
    s_vals = (pts - r0) @ u
    if side=='L':
        keep_idx = np.where(s_vals > 0)[0]; order = np.argsort(s_vals[keep_idx])
    else:
        keep_idx = np.where(s_vals < 0)[0]; order = np.argsort(-s_vals[keep_idx])
    ts_keep  = np.array(ts)[keep_idx][order]
    pts_keep = pts[keep_idx][order]
    ts_sorted  = [float(ts_keep[i]) for i in range(len(order))]
    pts_sorted = [tuple(pts_keep[i]) for i in range(len(order))]
    s_sorted   = list((pts_keep - r0) @ u)
    return ts_sorted, pts_sorted, s_sorted

def intersections_fixed_in(r, T, Rg, E, phi, t_fix_in):
    ts = find_roots(lambda t,*aa: H_line_fixed_in(r,T,Rg,E,t,*aa), (phi,), t_fix_in[0], t_fix_in[1])
    xs, ys = stat_in(r,T,np.array(ts)) if len(ts) else (np.array([]), np.array([]))
    return sort_by_halfline(r,T,Rg,E,phi,'L', list(zip(xs, ys)) if len(ts) else [], ts)
def intersections_orbit_out(r, T, Rg, E, phi, t_orb_out):
    ts = find_roots(lambda t,*aa: H_line_orbit_out(r,T,Rg,E,t,*aa), (phi,), t_orb_out[0], t_orb_out[1])
    if len(ts):
        xloc, yloc = orb_out_local(r,T,np.array(ts))
        xs, ys = translate_orbit(E, xloc, yloc, phi); xy = list(zip(xs, ys))
    else:
        xy = []
    return sort_by_halfline(r,T,Rg,E,phi,'L', xy, ts)
def intersections_fixed_out(r, T, Rg, E, phi, t_fix_out):
    ts = find_roots(lambda t,*aa: H_line_fixed_out(r,T,Rg,E,t,*aa), (phi,), t_fix_out[0], t_fix_out[1])
    xs, ys = stat_out(r,T,np.array(ts)) if len(ts) else (np.array([]), np.array([]))
    return sort_by_halfline(r,T,Rg,E,phi,'R', list(zip(xs, ys)) if len(ts) else [], ts)
def intersections_orbit_in(r, T, Rg, E, phi, t_orb_in):
    ts = find_roots(lambda t,*aa: H_line_orbit_in(r,T,Rg,E,t,*aa), (phi,), t_orb_in[0], t_orb_in[1])
    if len(ts):
        xloc, yloc = orb_in_local(r,T,np.array(ts))
        xs, ys = translate_orbit(E, xloc, yloc, phi); xy = list(zip(xs, ys))
    else:
        xy = []
    return sort_by_halfline(r,T,Rg,E,phi,'R', xy, ts)

# ========= True areas for adiabatic pressures =========
def poly_area_centroid(points):
    if len(points) < 3:
        return 0.0, np.nan, np.nan
    x = np.array([p[0] for p in points]); y = np.array([p[1] for p in points])
    x1 = np.roll(x, -1); y1 = np.roll(y, -1)
    cross = x*y1 - y*x1
    A_signed = 0.5 * np.sum(cross)
    if abs(A_signed) < 1e-15:
        return 0.0, np.nan, np.nan
    Cx = (1.0/(6.0*A_signed)) * np.sum((x + x1) * cross)
    Cy = (1.0/(6.0*A_signed)) * np.sum((y + y1) * cross)
    return abs(A_signed), Cx, Cy

def sample_stat_out(r,T,t0,t1,N=400):
    ts = np.linspace(t0,t1,max(2,N)); x,y = stat_out(r,T,ts); return list(zip(x,y))
def sample_stat_in(r,T,t0,t1,N=400):
    ts = np.linspace(t0,t1,max(2,N)); x,y = stat_in(r,T,ts);  return list(zip(x,y))
def sample_orb_out_global(r,T,E,s0,s1,phi,N=400):
    ts = np.linspace(s0,s1,max(2,N)); xloc,yloc = orb_out_local(r,T,ts); x,y = translate_orbit(E, xloc, yloc, phi); return list(zip(x,y))
def sample_orb_in_global(r,T,E,s0,s1,phi,N=400):
    ts = np.linspace(s0,s1,max(2,N)); xloc,yloc = orb_in_local(r,T,ts);  x,y = translate_orbit(E, xloc, yloc, phi);  return list(zip(x,y))

def pockets_true_A(r,T,Rg,E,phi, t_fix_in, t_orb_out):
    t_fix, _, _ = intersections_fixed_in(r,T,Rg,E,phi, t_fix_in)
    t_orb, _, _ = intersections_orbit_out(r,T,Rg,E,phi, t_orb_out)
    n = max(0, min(len(t_fix), len(t_orb)) - 1)
    areas = []
    for j in range(n):
        tf1, tf2 = t_fix[j], t_fix[j+1]
        to1, to2 = t_orb[j], t_orb[j+1]
        poly = []
        x1, y1 = translate_orbit(E, *orb_out_local(r,T,np.array([to1])), phi); PO1 = (float(x1), float(y1))
        x2, y2 = stat_in(r,T,np.array([tf1])); PF1 = (float(x2), float(y2))
        poly += [PO1, PF1]
        poly += sample_stat_in(r,T, tf1, tf2, N=300)[1:]
        x4, y4 = translate_orbit(E, *orb_out_local(r,T,np.array([to2])), phi); PO2 = (float(x4), float(y4))
        poly += [PO2]
        poly += sample_orb_out_global(r,T,E, to2, to1, phi, N=300)[1:]
        A_poly, _, _ = poly_area_centroid(poly); areas.append(A_poly)
    return areas

def pockets_true_B(r,T,Rg,E,phi, t_fix_out, t_orb_in):
    t_fix, _, _ = intersections_fixed_out(r,T,Rg,E,phi, t_fix_out)
    t_orb, _, _ = intersections_orbit_in(r,T,Rg,E,phi, t_orb_in)
    n = max(0, min(len(t_fix), len(t_orb)) - 1)
    areas = []
    for j in range(n):
        tf1, tf2 = t_fix[j], t_fix[j+1]
        to1, to2 = t_orb[j], t_orb[j+1]
        poly = []
        x1, y1 = translate_orbit(E, *orb_in_local(r,T,np.array([to1])), phi); PO1 = (float(x1), float(y1))
        x2, y2 = stat_out(r,T,np.array([tf1])); PF1 = (float(x2), float(y2))
        poly += [PO1, PF1]
        poly += sample_stat_out(r,T, tf1, tf2, N=300)[1:]
        x4, y4 = translate_orbit(E, *orb_in_local(r,T,np.array([to2])), phi); PO2 = (float(x4), float(y4))
        poly += [PO2]
        poly += sample_orb_in_global(r,T,E, to2, to1, phi, N=300)[1:]
        A_poly, _, _ = poly_area_centroid(poly); areas.append(A_poly)
    return areas

# ========= Build pA,pB (adiabatic) & per-phi pack =========
def build_base_forces(variant="R32"):
    V = VARIANTS[variant]
    Rg = V["Rg"]; r = Rg; T = V["T"]; phi0_deg = V["phi0_deg"]
    E = (2*pi*Rg - 2*T)/2.0
    t_fix_in  = np.deg2rad(V["N_fix_in_deg"]  + np.array([-EPS_FIX_DEG, +EPS_FIX_DEG]))
    t_fix_out = np.deg2rad(V["N_fix_out_deg"] + np.array([-EPS_FIX_DEG, +EPS_FIX_DEG]))
    t_orb_in  = np.deg2rad(V["N_orb_in_deg"]  + np.array([-EPS_ORB_DEG, +EPS_ORB_DEG]))
    t_orb_out = np.deg2rad(V["N_orb_out_deg"] + np.array([-EPS_ORB_DEG, +EPS_ORB_DEG]))

    num_main = int(360.0/DEG_STEP_MAIN)
    phis = [np.deg2rad(phi0_deg + DEG_STEP_MAIN*i) for i in range(num_main)]
    degs = [DEG_STEP_MAIN*i for i in range(num_main)]

    # anchors
    A_true0 = pockets_true_A(r,T,Rg,E, phis[0], t_fix_in, t_orb_out)[::-1]
    B_true180 = pockets_true_B(r,T,Rg,E, phis[(180//int(DEG_STEP_MAIN))], t_fix_out, t_orb_in)[::-1]
    A_anchor = A_true0[0] if len(A_true0)>0 else np.nan
    B_anchor = B_true180[0] if len(B_true180)>0 else np.nan

    per_phi = []
    for phi,deg in zip(phis,degs):
        # determine open side (for suction pocket pressure assignment)
        open_side = 'B' if deg < 180.0 else 'A'
        # true areas for pockets at this phi
        A_true = pockets_true_A(r,T,Rg,E, phi, t_fix_in, t_orb_out)[::-1]
        B_true = pockets_true_B(r,T,Rg,E, phi, t_fix_out, t_orb_in)[::-1]

        # suction true area just so p arrays align (value itself is Ps)
        if open_side=='A':
            A_tr = [np.nan] + A_true  # head is suction => Ps
            B_tr = B_true
        else:
            B_tr = [np.nan] + B_true
            A_tr = A_true

        # adiabatic pressures
        def p_from_anchor(lst, anchor):
            out=[]
            for Anow in lst:
                if np.isnan(anchor) or Anow is None or np.isnan(Anow) or Anow<=1e-12: out.append(np.nan)
                else: out.append(P_SUCTION_MP*((anchor/Anow)**GAMMA))
            return out
        pA = p_from_anchor(A_tr, A_anchor)
        pB = p_from_anchor(B_tr, B_anchor)

        # enforce suction = Ps on the head element of the open side
        if open_side=='A' and len(pA)>0: pA[0]=P_SUCTION_MP
        if open_side=='B' and len(pB)>0: pB[0]=P_SUCTION_MP

        per_phi.append(dict(phi=phi, deg=deg, pA=pA, pB=pB))
    return dict(Rg=Rg, r=r, T=T, E=E, t_fix_in=t_fix_in, t_fix_out=t_fix_out, per_phi=per_phi)

# ========= Theta sum term (center arc) =========
def theta_sum_terms_mm(r,T,Rg,E,phi, t_fix_in, t_fix_out):
    t_fix_L, _, _ = intersections_fixed_in(r,T,Rg,E,phi, t_fix_in)
    t_fix_R, _, _ = intersections_fixed_out(r,T,Rg,E,phi, t_fix_out)
    if len(t_fix_L)==0 or len(t_fix_R)==0: return np.nan
    tL = t_fix_L[0]; tR = t_fix_R[0]
    return Rg*(tL + tR)

# ========= Export function =========
def export_force_components(variant="R32", Pc1=5.0, out_csv=None):
    base = build_base_forces(variant)
    Rg = base["Rg"]; r=base["r"]; T=base["T"]; E=base["E"]
    t_fix_in=base["t_fix_in"]; t_fix_out=base["t_fix_out"]
    per_phi = base["per_phi"]

    rows = []
    max_err = 0.0
    for ent in per_phi:
        phi = ent["phi"]; deg = ent["deg"]
        ur = u_dir(phi); nt = n_perp(phi)

        # line loads
        Lr = 2.0*Rg*(Pc1 - P_SUCTION_MP)  # N/mm
        pA = ent["pA"]; pB = ent["pB"]
        Lt_terms = []
        for idx in [0,1]:
            if idx < len(pB) and not np.isnan(pB[idx]):
                Lt_terms.append((pB[idx]-P_SUCTION_MP)*(2.0*pi*Rg))
        for idx in [0,1,2]:
            if idx < len(pA) and not np.isnan(pA[idx]):
                Lt_terms.append((pA[idx]-P_SUCTION_MP)*(2.0*pi*Rg))
        Rg_theta = theta_sum_terms_mm(r,T,Rg,E,phi, t_fix_in, t_fix_out)
        if not np.isnan(Rg_theta):
            Lt_terms.append((Pc1 - P_SUCTION_MP)*Rg_theta)
        Lt = np.sum(Lt_terms) if len(Lt_terms) else 0.0

        # forces (N)
        F_radial  = -Lr * h_wrap     # inward negative (since Lr>0 when Pc1>Ps)
        F_tangent =  Lt * h_wrap

        Fx = F_radial*ur[0] + F_tangent*nt[0]
        Fy = F_radial*ur[1] + F_tangent*nt[1]

        lhs = F_radial**2 + F_tangent**2
        rhs = Fx**2 + Fy**2
        max_err = max(max_err, abs(lhs - rhs))

        rows.append(dict(phi_deg=float(deg),
                         F_radial=float(F_radial),
                         F_tangent=float(F_tangent),
                         F_x=float(Fx),
                         F_y=float(Fy)))

    df = pd.DataFrame(rows).sort_values("phi_deg").reset_index(drop=True)
    if out_csv is None:
        out_csv = f"/mnt/data/force_components_{variant}_Pc1_{Pc1:.1f}.csv"
    df.to_csv(out_csv, index=False)
    print("Wrote:", out_csv)
    print("Max |(Fr^2+Ft^2) - (Fx^2+Fy^2)| =", max_err)
    return df, out_csv, max_err

if __name__ == "__main__":
    # Example: R32 at Pc1=5.0 MPa
    export_force_components("R32", 5.0)
