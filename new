# === Full pipeline: Areas + Centroids + Pressures + Forces + Moments (R32/R290) ===
# This script builds exact-tiling chamber geometry, computes areas/centroids,
# adiabatic pressures, detailed forces, and ring-overturning moments, then exports CSVs.
#
# Notes:
# - Centerlines + Green's theorem (analytic) for arcs, line-segment closure at winding ends.
# - Endpoint root "snap-to-RAW" and s-pairing fix for strict tiling (sum_area constant).
# - Suction patch (area & centroid) added as given per variant.
#
import numpy as np
import pandas as pd
import os, math
import matplotlib.pyplot as plt

# ----------------------------- Variants -----------------------------
VARIANTS = {
    "R32": dict(
        # involute geometry
        Rg=2.62606, T=3.65, phi0_deg=217.0,
        N_fix_in_deg  = np.array([283.0, 1223.5]),
        N_fix_out_deg = np.array([ 76.0,  863.5]),
        N_orb_in_deg  = np.array([254.0, 1043.0]),
        N_orb_out_deg = np.array([107.0, 1043.0]),
        # suction patch (beyond centerline chain)
        PATCH_AREA=350.1413, PATCH_CX=-44.7559, PATCH_CY=16.2285,
        # thermodynamics
        GAMMA=1.45, P_suction_MP=1.0, P_C1_MP=5.0,
        # ring + heights
        mirror_radius=58.0,
        h_wrap=35.2, h_mirror=8.5, h_main_bearing=31.5,
        # bottom/lateral
        P_middle=1.4,
        p_m_point=np.array([0.2321, 5.2002]),   # centroid for P_middle
        seal_radius=57.6/2,
        P_seal_point=np.array([-0.9496, 4.0354]),
    ),
    "R290": dict(
        Rg=2.51465, T=3.30, phi0_deg=169.0,
        N_fix_in_deg  = np.array([283.0, 1271.5]),
        N_fix_out_deg = np.array([ 86.0,  911.5]),
        N_orb_in_deg  = np.array([264.0, 1090.5]),
        N_orb_out_deg = np.array([107.0, 1090.5]),
        PATCH_AREA=331.6113, PATCH_CX=-42.0522, PATCH_CY=-22.4137,
        GAMMA=1.20, P_suction_MP=1.0, P_C1_MP=5.0,
        mirror_radius=60.0,
        h_wrap=34.0, h_mirror=8.0, h_main_bearing=31.5,
        P_middle=1.4,
        p_m_point=np.array([-3.5111, 3.5388]),
        seal_radius=57.6/2,
        P_seal_point=np.array([-3.6140, 2.0259]),
    ),
}

# Root-finding window expansions (for finding intersections only)
EPS_FIX_DEG = 0.6
EPS_ORB_DEG = 1.2
# Endpoint snap and pairing tolerances
SNAP_TOL_DEG = 0.30         # snap roots to RAW endpoints if within this angle
PAIR_TOL_S   = 2e-3         # s-coincidence tolerance (mm)

# ----------------------------- Core geometry & intersections -----------------------------
def build_geom(variant):
    Rg = variant["Rg"]; T=variant["T"]; r=Rg
    phi0_deg = variant["phi0_deg"]
    E = (2*np.pi*Rg - 2*T) / 2.0

    # RAW winding ranges (no EPS here)
    t_fix_in_raw  = np.deg2rad(variant["N_fix_in_deg"] )
    t_fix_out_raw = np.deg2rad(variant["N_fix_out_deg"])
    t_orb_in_raw  = np.deg2rad(variant["N_orb_in_deg"] )
    t_orb_out_raw = np.deg2rad(variant["N_orb_out_deg"])

    # EPS-extended ranges for root finding
    t_fix_in_eps  = np.deg2rad(variant["N_fix_in_deg"]  + np.array([-EPS_FIX_DEG, +EPS_FIX_DEG]))
    t_fix_out_eps = np.deg2rad(variant["N_fix_out_deg"] + np.array([-EPS_FIX_DEG, +EPS_FIX_DEG]))
    t_orb_in_eps  = np.deg2rad(variant["N_orb_in_deg"]  + np.array([-EPS_ORB_DEG, +EPS_ORB_DEG]))
    t_orb_out_eps = np.deg2rad(variant["N_orb_out_deg"] + np.array([-EPS_ORB_DEG, +EPS_ORB_DEG]))
    SNAP_TOL = np.deg2rad(SNAP_TOL_DEG)

    # local frames
    def u_dir(phi):  return np.array([np.cos(phi), -np.sin(phi)])
    def n_perp(phi): return np.array([np.sin(phi),  np.cos(phi)])

    # centerlines
    def P_stat_center(t):
        return np.array([-r*(np.sin(t) - t*np.cos(t)),  r*(np.cos(t) + t*np.sin(t))])
    def P_orb_center(t, phi):
        X0, Y0 = E*np.cos(phi), -E*np.sin(phi)
        return np.array([ r*(np.sin(t) - t*np.cos(t)) + X0, -r*(np.cos(t) + t*np.sin(t)) + Y0 ])

    # flanks (for intersection only)
    def stat_out(t):
        x = -r*(np.sin(t) - t*np.cos(t)) + (T/2.0)*np.cos(t)
        y =  r*(np.cos(t) + t*np.sin(t)) + (T/2.0)*np.sin(t)
        return x, y
    def stat_in(t):
        x = -r*(np.sin(t) - t*np.cos(t)) - (T/2.0)*np.cos(t)
        y =  r*(np.cos(t) + t*np.sin(t)) - (T/2.0)*np.sin(t)
        return x, y
    def orb_out_local(t):
        x =  r*(np.sin(t) - t*np.cos(t)) - (T/2.0)*np.cos(t)
        y = -r*(np.cos(t) + t*np.sin(t)) - (T/2.0)*np.sin(t)
        return x, y
    def orb_in_local(t):
        x =  r*(np.sin(t) - t*np.cos(t)) + (T/2.0)*np.cos(t)
        y = -r*(np.cos(t) + t*np.sin(t)) + (T/2.0)*np.sin(t)
        return x, y
    def translate_orbit(x, y, phi):
        return x + E*np.cos(phi), y - E*np.sin(phi)

    # half-line signed distance tests
    def H_line_fixed_in(t, phi):
        n = n_perp(phi); r0 =  Rg*n
        x, y = stat_in(t);  return n[0]*(x - r0[0]) + n[1]*(y - r0[1])
    def H_line_fixed_out(t, phi):
        n = n_perp(phi); r0 = -Rg*n
        x, y = stat_out(t); return n[0]*(x - r0[0]) + n[1]*(y - r0[1])
    def H_line_orbit_out(t, phi):
        n = n_perp(phi); r0 =  Rg*n
        x, y = translate_orbit(*orb_out_local(t), phi); return n[0]*(x - r0[0]) + n[1]*(y - r0[1])
    def H_line_orbit_in(t, phi):
        n = n_perp(phi); r0 = -Rg*n
        x, y = translate_orbit(*orb_in_local(t), phi);  return n[0]*(x - r0[0]) + n[1]*(y - r0[1])

    # robust 1D bisection
    def _bisect(func, a, b, phi, itmax=60, tol=1e-12):
        fa, fb = func(a, phi), func(b, phi)
        if fa*fb > 0: return None
        lo, hi, flo, fhi = a, b, fa, fb
        for _ in range(itmax):
            m = 0.5*(lo + hi); fm = func(m, phi)
            if abs(fm) <= 1e-14 or (hi-lo)/2 < tol*(1+abs(m)): return m
            if flo*fm <= 0: hi, fhi = m, fm
            else:           lo, flo = m, fm
        return 0.5*(lo + hi)

    # dense scan + snap-to-RAW at endpoints
    def find_roots(func, phi, tmin, tmax, M=24000, tol_zero=1e-9):
        ts = np.linspace(tmin, tmax, M+1)
        Hs = func(ts, phi)
        roots = []
        nz = np.where(np.abs(Hs) <= tol_zero)[0].tolist()
        for i in nz: roots.append(ts[i])
        for i in range(M):
            a, b, fa, fb = ts[i], ts[i+1], Hs[i], Hs[i+1]
            if fa*fb < 0:
                m = _bisect(func, a, b, phi)
                if m is not None: roots.append(m)
            else:
                if abs(fa) < 10*tol_zero:
                    left = max(tmin, a - (tmax-tmin)/M)
                    m = _bisect(func, left, min(b, a+(tmax-tmin)/M), phi)
                    if m is not None: roots.append(m)
                if abs(fb) < 10*tol_zero:
                    right = min(tmax, b + (tmax-tmin)/M)
                    m = _bisect(func, max(a, b-(tmax-tmin)/M), right, phi)
                    if m is not None: roots.append(m)
        snapped = []
        for t in roots:
            if abs(t - tmin) <= SNAP_TOL: t = tmin
            if abs(t - tmax) <= SNAP_TOL: t = tmax
            snapped.append(t)
        roots = sorted(set([float(np.round(t, 12)) for t in snapped]))
        return roots

    # sort intersections along half-line; return (t, pts, s) with SNAP already applied
    def sort_by_halfline(phi, side, xy_pts, ts):
        if len(ts) == 0: return [], [], []
        n = n_perp(phi); u = u_dir(phi)
        r0 = ( Rg*n if side=='L' else -Rg*n )
        pts = np.array(xy_pts) if len(xy_pts) else np.zeros((0,2))
        s_vals = (pts - r0) @ u if len(xy_pts) else np.array([])
        if side=='L':
            keep_idx = np.where(s_vals > 0)[0]; order = np.argsort(s_vals[keep_idx])  # inner->outer
        else:
            keep_idx = np.where(s_vals < 0)[0]; order = np.argsort(-s_vals[keep_idx]) # inner->outer
        ts_keep  = np.array(ts)[keep_idx][order]
        pts_keep = pts[keep_idx][order] if len(pts) else pts
        s_keep   = (pts_keep - r0) @ u if len(pts_keep) else np.array([])
        return [float(x) for x in ts_keep], [tuple(p) for p in pts_keep], [float(x) for x in s_keep]

    # intersection wrappers
    def intersections_fixed_in(phi):
        ts = find_roots(H_line_fixed_in, phi, t_fix_in_eps[0], t_fix_in_eps[1])
        xs, ys = stat_in(np.array(ts)) if len(ts) else (np.array([]), np.array([]))
        return sort_by_halfline(phi, 'L', list(zip(xs, ys)) if len(ts) else [], ts)
    def intersections_orbit_out(phi):
        ts = find_roots(H_line_orbit_out, phi, t_orb_out_eps[0], t_orb_out_eps[1])
        if len(ts):
            xloc, yloc = orb_out_local(np.array(ts))
            xs, ys = translate_orbit(xloc, yloc, phi); xy = list(zip(xs, ys))
        else:
            xy = []
        return sort_by_halfline(phi, 'L', xy, ts)
    def intersections_fixed_out(phi):
        ts = find_roots(H_line_fixed_out, phi, t_fix_out_eps[0], t_fix_out_eps[1])
        xs, ys = stat_out(np.array(ts)) if len(ts) else (np.array([]), np.array([]))
        return sort_by_halfline(phi, 'R', list(zip(xs, ys)) if len(ts) else [], ts)
    def intersections_orbit_in(phi):
        ts = find_roots(H_line_orbit_in, phi, t_orb_in_eps[0], t_orb_in_eps[1])
        if len(ts):
            xloc, yloc = orb_in_local(np.array(ts))
            xs, ys = translate_orbit(xloc, yloc, phi); xy = list(zip(xs, ys))
        else:
            xy = []
        return sort_by_halfline(phi, 'R', xy, ts)

    # Green-form analytic pieces
    def area_line_seg(p, q): return 0.5 * (p[0]*q[1] - p[1]*q[0])
    def Mx_line_seg(p, q):   return ((p[0] + q[0]) / 3.0) * area_line_seg(p, q)
    def My_line_seg(p, q):   return ((p[1] + q[1]) / 3.0) * area_line_seg(p, q)

    def A_stat_center(t0, t1): return (r*r/6.0) * (t1**3 - t0**3)
    def F_stat_Mx(t):
        return (r**3/3.0)*( t**3*np.sin(t) + 4.0*t**2*np.cos(t) - 8.0*t*np.sin(t) - 8.0*np.cos(t) )
    def F_stat_My(t):
        return (r**3/3.0)*( -t**3*np.cos(t) + 4.0*t**2*np.sin(t) + 8.0*t*np.cos(t) - 8.0*np.sin(t) )
    def Mx_stat_center(t0, t1): return F_stat_Mx(t1) - F_stat_Mx(t0)
    def My_stat_center(t0, t1): return F_stat_My(t1) - F_stat_My(t0)

    def F_stat_S1(t):
        return (r**2)*((t**3)/6.0 + (t**2)*np.sin(2*t)/4.0 + t*np.cos(2*t)/2.0 - np.sin(2*t)/4.0)
    def F_stat_S2(t):
        return (r**2)*(-(t**3)/6.0 + (t**2)*np.sin(2*t)/4.0 + t*np.cos(2*t)/2.0 - np.sin(2*t)/4.0)
    def S1_stat(t0, t1): return F_stat_S1(t1) - F_stat_S1(t0)
    def S2_stat(t0, t1): return F_stat_S2(t1) - F_stat_S2(t0)

    def A_orb_center(t0, t1, phi):
        base = (r*r/6.0) * (t1**3 - t0**3)
        def F(t): return t*np.sin(phi + t) + np.cos(phi + t)
        trans = -0.5 * E * r * (F(t1) - F(t0))
        return base + trans
    def Mx_orb_center(t0, t1, phi):
        X0, Y0 = E*np.cos(phi), -E*np.sin(phi)
        p = P_stat_center(t0); q = P_stat_center(t1)
        dx = q[0] - p[0]; dy = q[1] - p[1]; dx2 = q[0]**2 - p[0]**2
        return (- Mx_stat_center(t0, t1)
                + (2*X0*S1_stat(t0,t1) - X0*S2_stat(t0,t1) - 0.5*Y0*dx2 - (X0**2)*dy + X0*Y0*dx)/3.0)
    def My_orb_center(t0, t1, phi):
        X0, Y0 = E*np.cos(phi), -E*np.sin(phi)
        p = P_stat_center(t0); q = P_stat_center(t1)
        dx = q[0] - p[0]; dy = q[1] - p[1]; dy2 = q[1]**2 - p[1]**2
        return (- My_stat_center(t0, t1)
                + (0.5*X0*dy2 + Y0*S1_stat(t0,t1) - X0*Y0*dy - 2*Y0*S2_stat(t0,t1) + (Y0**2)*dx)/3.0)

    # pairing by progress (|s|) but equality by signed s
    def common_pairs_progress(s_fix, t_fix, s_orb, t_orb, tol_signed=PAIR_TOL_S):
        i=j=0; pairs=[]
        a = np.abs(s_fix); b = np.abs(s_orb)
        while i<len(s_fix) and j<len(s_orb):
            d_signed = s_fix[i] - s_orb[j]
            if abs(d_signed) <= tol_signed:
                pairs.append((i,j)); i+=1; j+=1
            else:
                if a[i] < b[j]:
                    i += 1
                else:
                    j += 1
        return pairs

    # clamp helper
    def clamp(t, tmin, tmax): return max(tmin, min(tmax, t))

    # --- Rooms A ---
    def chambers_A_props(phi):
        tF, _, sF = intersections_fixed_in(phi)
        tO, _, sO = intersections_orbit_out(phi)
        if len(tF)==0 or len(tO)==0: return []
        tF_c = [clamp(t, t_fix_in_raw[0],  t_fix_in_raw[1]) for t in tF]
        tO_c = [clamp(t, t_orb_out_raw[0], t_orb_out_raw[1]) for t in tO]
        pairs = common_pairs_progress(np.array(sF), tF_c, np.array(sO), tO_c)
        out=[]
        for k in range(len(pairs)-1):
            i1,j1 = pairs[k]; i2,j2 = pairs[k+1]
            t1, t2 = tF_c[i1], tF_c[i2]
            s1, s2 = tO_c[j1], tO_c[j2]
            P1o, P1f = P_orb_center(s1,phi), P_stat_center(t1)
            P2f, P2o = P_stat_center(t2),   P_orb_center(s2,phi)
            A  = area_line_seg(P1o, P1f) + A_stat_center(t1, t2) + area_line_seg(P2f, P2o) + A_orb_center(s2, s1, phi)
            Mx = Mx_line_seg(P1o, P1f)   + Mx_stat_center(t1, t2) + Mx_line_seg(P2f, P2o)   + Mx_orb_center(s2, s1, phi)
            My = My_line_seg(P1o, P1f)   + My_stat_center(t1, t2) + My_line_seg(P2f, P2o)   + My_orb_center(s2, s1, phi)
            if A < 0: A, Mx, My = -A, -Mx, -My
            out.append(dict(area=A, cx=Mx/A if abs(A)>1e-12 else np.nan, cy=My/A if abs(A)>1e-12 else np.nan))
        return out[::-1]  # A1 outermost

    # --- Rooms B ---
    def chambers_B_props(phi):
        tF, _, sF = intersections_fixed_out(phi)
        tO, _, sO = intersections_orbit_in(phi)
        if len(tF)==0 or len(tO)==0: return []
        tF_c = [clamp(t, t_fix_out_raw[0], t_fix_out_raw[1]) for t in tF]
        tO_c = [clamp(t, t_orb_in_raw[0],  t_orb_in_raw[1])  for t in tO]
        pairs = common_pairs_progress(np.array(sF), tF_c, np.array(sO), tO_c)
        out=[]
        for k in range(len(pairs)-1):
            i1,j1 = pairs[k]; i2,j2 = pairs[k+1]
            t1, t2 = tF_c[i1], tF_c[i2]
            s1, s2 = tO_c[j1], tO_c[j2]
            P1o, P1f = P_orb_center(s1,phi), P_stat_center(t1)
            P2f, P2o = P_stat_center(t2),   P_or_center(s2:=s2, phi:=phi) if False else (P_stat_center(t2), P_orb_center(s2,phi))  # no-op, safety
            P2f, P2o = P_stat_center(t2),   P_orb_center(s2,phi)
            A  = area_line_seg(P1o, P1f) + A_stat_center(t1, t2) + area_line_seg(P2f, P2o) + A_orb_center(s2, s1, phi)
            Mx = Mx_line_seg(P1o, P1f)   + Mx_stat_center(t1, t2) + Mx_line_seg(P2f, P2o)   + Mx_orb_center(s2, s1, phi)
            My = My_line_seg(P1o, P1f)   + My_stat_center(t1, t2) + My_line_seg(P2f, P2o)   + My_orb_center(s2, s1, phi)
            if A < 0: A, Mx, My = -A, -Mx, -My
            out.append(dict(area=A, cx=Mx/A if abs(A)>1e-12 else np.nan, cy=My/A if abs(A)>1e-12 else np.nan))
        return out[::-1]  # B1 outermost

    # --- C1 (inner-most paired intersections on each side) ---
    def chamber_C1_props(phi):
        t_fix_L, _, s_fixL = intersections_fixed_in(phi)
        t_orb_L, _, s_orbL = intersections_orbit_out(phi)
        t_fix_R, _, s_fixR = intersections_fixed_out(phi)
        t_orb_R, _, s_orbR = intersections_orbit_in(phi)
        if (len(t_fix_L)==0 or len(t_orb_L)==0 or len(t_fix_R)==0 or len(t_orb_R)==0):
            return dict(area=np.nan, cx=np.nan, cy=np.nan, theta_sum=np.nan)
        t_fix_L = [max(min(t, t_fix_in_raw[1]),  t_fix_in_raw[0]) for t in t_fix_L]
        t_orb_L = [max(min(t, t_orb_out_raw[1]), t_orb_out_raw[0]) for t in t_orb_L]
        t_fix_R = [max(min(t, t_fix_out_raw[1]), t_fix_out_raw[0]) for t in t_fix_R]
        t_orb_R = [max(min(t, t_orb_in_raw[1]),  t_orb_in_raw[0])  for t in t_orb_R]
        pairsL = common_pairs_progress(np.array(s_fixL), t_fix_L, np.array(s_orbL), t_orb_L)
        pairsR = common_pairs_progress(np.array(s_fixR), t_fix_R, np.array(s_orbR), t_orb_R)
        if len(pairsL)==0 or len(pairsR)==0:
            return dict(area=np.nan, cx=np.nan, cy=np.nan, theta_sum=np.nan)
        iL,jL = pairsL[0]; iR,jR = pairsR[0]
        tL, sL = t_fix_L[iL], t_orb_L[jL]
        tR, sR = t_fix_R[iR], t_orb_R[jR]
        P_stat_L, P_stat_R = P_stat_center(tL), P_stat_center(tR)
        P_orb_L,  P_orb_R  = P_orb_center(sL, phi), P_orb_center(sR, phi)
        A  = area_line_seg(P_stat_L, P_orb_L) + A_orb_center(sL, sR, phi) \
           + area_line_seg(P_orb_R, P_stat_R) + A_stat_center(tR, tL)
        Mx = Mx_line_seg(P_stat_L, P_orb_L) + Mx_orb_center(sL, sR, phi) \
           + Mx_line_seg(P_orb_R, P_stat_R) + Mx_stat_center(tR, tL)
        My = My_line_seg(P_stat_L, P_orb_L) + My_orb_center(sL, sR, phi) \
           + My_line_seg(P_orb_R, P_stat_R) + My_stat_center(tR, tL)
        if A < 0: A, Mx, My = -A, -Mx, -My
        d = np.linalg.norm(P_stat_R - P_stat_L)
        theta_sum = np.sqrt(max(d*d - (2*Rg)**2, 0.0)) / Rg
        return dict(area=A, cx=Mx/A if A>1e-12 else np.nan, cy=My/A if A>1e-12 else np.nan, theta_sum=theta_sum)

    # --- Suction: OUTERMOST paired intersections as anchors (perfect tiling) ---
    def suction_props_ccw(phi):
        # get all intersections & s
        t_fix_L, _, s_fixL = intersections_fixed_in(phi)
        t_orb_L, _, s_orbL = intersections_orbit_out(phi)
        t_fix_R, _, s_fixR = intersections_fixed_out(phi)
        t_orb_R, _, s_orbR = intersections_orbit_in(phi)
        if (len(t_fix_L)==0 or len(t_orb_L)==0 or len(t_fix_R)==0 or len(t_orb_R)==0):
            return dict(area=np.nan, cx=np.nan, cy=np.nan)
        # clamp
        t_fix_Lc = [max(min(t, t_fix_in_raw[1]),  t_fix_in_raw[0]) for t in t_fix_L]
        t_orb_Lc = [max(min(t, t_orb_out_raw[1]), t_orb_out_raw[0]) for t in t_orb_L]
        t_fix_Rc = [max(min(t, t_fix_out_raw[1]), t_fix_out_raw[0]) for t in t_fix_R]
        t_orb_Rc = [max(min(t, t_orb_in_raw[1]),  t_orb_in_raw[0])  for t in t_orb_R]
        # pairs on each side
        pairsL = common_pairs_progress(np.array(s_fixL), t_fix_Lc, np.array(s_orbL), t_orb_Lc)
        pairsR = common_pairs_progress(np.array(s_fixR), t_fix_Rc, np.array(s_orbR), t_orb_Rc)
        if len(pairsL)==0 or len(pairsR)==0:
            return dict(area=np.nan, cx=np.nan, cy=np.nan)
        # OUTERMOST pair as anchors for suction
        iL,jL = pairsL[-1]; iR,jR = pairsR[-1]
        tfL, toL = t_fix_Lc[iL], t_orb_Lc[jL]
        tfR, toR = t_fix_Rc[iR], t_orb_Rc[jR]
        # constant ends
        tf_in_end  = t_fix_in_raw[1]
        tf_out_end = t_fix_out_raw[1]
        to_in_end  = t_orb_in_raw[1]
        to_out_end = t_orb_out_raw[1]

        # points
        P = lambda t: P_stat_center(t)
        Q = lambda s: P_orb_center(s, phi)
        P_tfL, P_tf_inEnd, P_tf_outEnd, P_tfR = P(tfL), P(tf_in_end), P(tf_out_end), P(tfR)
        P_toR, P_to_inEnd, P_to_outEnd, P_toL = Q(toR), Q(to_in_end), Q(to_out_end), Q(toL)

        # chain
        A=0.0; Mx=0.0; My=0.0
        def add_seg(p, q):
            nonlocal A,Mx,My
            a = 0.5*(p[0]*q[1]-p[1]*q[0])
            A += a; Mx += ((p[0]+q[0])/3.0)*a; My += ((p[1]+q[1])/3.0)*a
        def add_stat(t0,t1):
            nonlocal A,Mx,My
            A += A_stat_center(t0,t1); Mx += Mx_stat_center(t0,t1); My += My_stat_center(t0,t1)
        def add_orb(s0,s1):
            nonlocal A,Mx,My
            A += A_orb_center(s0,s1,phi); Mx += Mx_orb_center(s0,s1,phi); My += My_orb_center(s0,s1,phi)

        add_stat(tfL, tf_in_end)
        add_seg(P_tf_inEnd, P_tf_outEnd)
        add_stat(tf_out_end, tfR)
        add_seg(P_tfR, P_toR)
        add_orb(toR, to_in_end)
        add_seg(P_to_inEnd, P_to_outEnd)
        add_orb(to_out_end, toL)
        add_seg(P_toL, P_tfL)

        if A < 0: A, Mx, My = -A, -Mx, -My

        # patch add
        A_tot = A + variant["PATCH_AREA"]
        Cx = (Mx + variant["PATCH_AREA"]*variant["PATCH_CX"]) / A_tot if A_tot>1e-12 else np.nan
        Cy = (My + variant["PATCH_AREA"]*variant["PATCH_CY"]) / A_tot if A_tot>1e-12 else np.nan
        return dict(area=A_tot, cx=Cx, cy=Cy)

    return dict(
        # geometry constants
        Rg=Rg, r=r, T=T, E=E, phi0_deg=phi0_deg,
        # primitives
        P_stat_center=P_stat_center, P_orb_center=P_orb_center,
        A_stat_center=A_stat_center, A_orb_center=A_orb_center,
        Mx_stat_center=Mx_stat_center, My_stat_center=My_stat_center,
        Mx_orb_center=Mx_orb_center, My_orb_center=My_orb_center,
        area_line_seg=area_line_seg, Mx_line_seg=Mx_line_seg, My_line_seg=My_line_seg,
        # intersections
        intersections_fixed_in=intersections_fixed_in,
        intersections_orbit_out=intersections_orbit_out,
        intersections_fixed_out=intersections_fixed_out,
        intersections_orbit_in=intersections_orbit_in,
        # pairing-based rooms
        chambers_A_props=chambers_A_props, chambers_B_props=chambers_B_props,
        chamber_C1_props=chamber_C1_props, suction_props_ccw=suction_props_ccw,
        # frames
        u_dir=u_dir, n_perp=n_perp
    )

# ----------------------------- Pressure model -----------------------------
def baseline_areas_for_adiabatic(geom, variant):
    """B side at 0°, A side at 180° (without suction inserted)."""
    phi0 = np.deg2rad(geom["phi0_deg"] + 0.0)
    phi180 = np.deg2rad(geom["phi0_deg"] + 180.0)
    Ab = geom["chambers_A_props"](phi180)  # A1.. (no suction inserted here)
    Bb = geom["chambers_B_props"](phi0)    # B1..
    return dict(
        A2=Ab[1]["area"] if len(Ab)>1 else np.nan,
        A3=Ab[2]["area"] if len(Ab)>2 else np.nan,
        B2=Bb[1]["area"] if len(Bb)>1 else np.nan
    )

def chamber_pressures(phi_deg_rel, A_pack, B_pack, C1, baseline, variant):
    P_s = variant["P_suction_MP"]; gamma = variant["GAMMA"]; P_C = variant["P_C1_MP"]
    out = {}
    # A side
    if len(A_pack)>0: out["A1"] = P_s
    if len(A_pack)>1 and not np.isnan(baseline.get("A2", np.nan)) and A_pack[1]["area"]>1e-9:
        out["A2"] = P_s * (baseline["A2"]/A_pack[1]["area"])**gamma
    if len(A_pack)>2 and not np.isnan(baseline.get("A3", np.nan)) and A_pack[2]["area"]>1e-9:
        out["A3"] = P_s * (baseline["A3"]/A_pack[2]["area"])**gamma
    # B side
    if len(B_pack)>0: out["B1"] = P_s
    if len(B_pack)>1 and not np.isnan(baseline.get("B2", np.nan)) and B_pack[1]["area"]>1e-9:
        out["B2"] = P_s * (baseline["B2"]/B_pack[1]["area"])**gamma
    # center
    if not np.isnan(C1["area"]) and C1["area"]>0: out["C1"] = P_C
    return out

# ----------------------------- Forces & Moments -----------------------------
def ring_origins(phi, variant, geom, deg_step2=10.0):
    E = geom["E"]; Rm = variant["mirror_radius"]
    out=[]
    for j in range(int(360/deg_step2)):
        th = phi + math.radians(j*deg_step2)   # 0°: radial (phi), 10°: phi+10° ...
        x = E*math.cos(phi) + Rm*math.cos(th)
        y = -E*math.sin(phi) - Rm*math.sin(th)
        out.append(np.array([x,y]))
    return out

def radial_unit_from_Oj(Oj):
    v = -Oj; n = np.linalg.norm(v);  return v/n if n>0 else np.array([1.0,0.0])

def top_thrust_moment_scalar(A_pack, B_pack, C1, pressures, Oj, n_dir):
    mvec = np.array([0.0,0.0])
    def add(area, cx, cy, P):
        if np.isnan(area) or area<=0 or np.isnan(P): return
        F = P * area
        r = np.array([cx - Oj[0], cy - Oj[1], 0.0])
        m = np.array([-F*r[1], F*r[0]])
        return m
    for idx, nm in enumerate(["A1","A2","A3"]):
        if idx < len(A_pack) and nm in pressures:
            m = add(A_pack[idx]["area"], A_pack[idx]["cx"], A_pack[idx]["cy"], pressures[nm]); 
            if m is not None: mvec += m
    for idx, nm in enumerate(["B1","B2"]):
        if idx < len(B_pack) and nm in pressures:
            m = add(B_pack[idx]["area"], B_pack[idx]["cx"], B_pack[idx]["cy"], pressures[nm]);
            if m is not None: mvec += m
    if "C1" in pressures and not np.isnan(C1["area"]):
        m = add(C1["area"], C1["cx"], C1["cy"], pressures["C1"]); 
        if m is not None: mvec += m
    return float(mvec @ n_dir)

def bottom_thrust_moment_scalar(variant, Oj, n_dir, area_sum, pressures):
    P_middle = variant["P_middle"]; P_C1 = pressures.get("C1", variant["P_C1_MP"])
    p_m = variant["p_m_point"]; p_seal = variant["P_seal_point"]
    A_seal = math.pi * (variant["seal_radius"]**2)
    mvec = np.array([0.0,0.0])
    def add(F, px, py):
        r = np.array([px - Oj[0], py - Oj[1], 0.0])
        m = np.array([ F*r[1], -F*r[0] ])
        return m
    if area_sum>0 and P_middle>0:
        Fm = P_middle * area_sum; mvec += add(Fm, p_m[0], p_m[1])
    if (P_C1 - P_middle) != 0:
        Fseal = (P_C1 - P_middle) * A_seal; mvec += add(Fseal, p_seal[0], p_seal[1])
    return float(- (mvec @ n_dir))  # stabilizing

def lateral_force_vector(variant, geom, phi, pressures, A_pack, B_pack, C1):
    Rg = geom["Rg"]; u = geom["u_dir"](phi); n = geom["n_perp"](phi); P_s = variant["P_suction_MP"]
    P_C = pressures.get("C1", variant["P_C1_MP"])
    F_rad_mag = 2*Rg*(P_C - P_s); F_rad_vec = -F_rad_mag * u
    def deltaP(name, pack, idx):
        if idx < len(pack) and name in pressures: return max(pressures[name] - P_s, 0.0)
        return 0.0
    F_tan_mag = 0.0
    F_tan_mag += deltaP("B1", B_pack, 0) * (2*math.pi*Rg)
    F_tan_mag += deltaP("B2", B_pack, 1) * (2*math.pi*Rg)
    F_tan_mag += deltaP("A1", A_pack, 0) * (2*math.pi*Rg)
    F_tan_mag += deltaP("A2", A_pack, 1) * (2*math.pi*Rg)
    F_tan_mag += deltaP("A3", A_pack, 2) * (2*math.pi*Rg)
    theta_sum = C1.get("theta_sum", np.nan)
    if not np.isnan(theta_sum): F_tan_mag += max(P_C - P_s, 0.0) * Rg * theta_sum
    F_tan_vec = F_tan_mag * n
    return F_rad_vec + F_tan_vec

def lateral_moment_scalar(variant, geom, phi, Oj, n_dir, pressures, A_pack, B_pack, C1):
    F_lat = lateral_force_vector(variant, geom, phi, pressures, A_pack, B_pack, C1)
    h_arm = variant["h_wrap"]/2.0 + variant["h_mirror"] + variant["h_main_bearing"]/2.0
    M_lat_vec = h_arm * np.array([-F_lat[1], F_lat[0]])
    return float(M_lat_vec @ n_dir), F_lat

# ----------------------------- Directory builder -----------------------------
def build_outdir(base_root, variant_name, variant, deg_step, deg_step2):
    vs = variant_name.lower()
    Ps = variant["P_suction_MP"]; Pd = variant["P_C1_MP"]; G = variant["GAMMA"]
    Pm = variant["P_middle"]; Rm = variant["mirror_radius"]
    harm = variant["h_wrap"]/2.0 + variant["h_mirror"] + variant["h_main_bearing"]/2.0
    dir_name = f"sim_{vs}__Ps{Ps:.2f}_Pd{Pd:.2f}_G{G:.2f}_Pm{Pm:.2f}_Rm{Rm:.1f}_h{harm:.1f}_d{int(deg_step)}_d2{int(deg_step2)}"
    outdir = os.path.join(base_root, dir_name); plots_dir = os.path.join(outdir, "plots")
    os.makedirs(plots_dir, exist_ok=True)
    return outdir, plots_dir

# ----------------------------- Sweep & export -----------------------------
def solve_and_export(variant_name="R32", deg_step=10.0, deg_step2=10.0, make_plots=False, base_root="/mnt/data"):
    variant = VARIANTS[variant_name]
    geom = build_geom(variant)
    baselines = baseline_areas_for_adiabatic(geom, variant)

    outdir, plots_dir = build_outdir(base_root, variant_name, variant, deg_step, deg_step2)
    csv_areas  = os.path.join(outdir, f"{variant_name}_areas_centroids_{int(deg_step)}deg.csv")
    csv_worst  = os.path.join(outdir, f"{variant_name}_worst_moment_{int(deg_step)}deg.csv")
    csv_forces = os.path.join(outdir, f"{variant_name}_forces_detailed_{int(deg_step)}deg.csv")

    phis = [np.deg2rad(geom["phi0_deg"] + deg_step*i) for i in range(int(360/deg_step))]
    phi_deg_rel = [deg_step*i for i in range(int(360/deg_step))]

    rows_area=[]; rows_worst=[]; rows_force=[]
    sums=[]

    for phi,deg in zip(phis, phi_deg_rel):
        A_rooms = geom["chambers_A_props"](phi)
        B_rooms = geom["chambers_B_props"](phi)
        C1 = geom["chamber_C1_props"](phi)
        Su = geom["suction_props_ccw"](phi)
        if deg >= 180.0:
            A_pack = [dict(area=Su["area"], cx=Su["cx"], cy=Su["cy"])] + A_rooms
            B_pack = B_rooms
        else:
            B_pack = [dict(area=Su["area"], cx=Su["cx"], cy=Su["cy"])] + B_rooms
            A_pack = A_rooms

        # pressures
        pressures = chamber_pressures(deg, A_pack, B_pack, C1, baselines, variant)

        # area sum
        total_area = (sum(d["area"] for d in A_pack) +
                      sum(d["area"] for d in B_pack) +
                      (C1["area"] if not np.isnan(C1["area"]) else 0.0))
        sums.append(total_area)

        # --- areas row ---
        def get(pk, idx, key):
            return pk[idx][key] if idx < len(pk) else np.nan
        area_row = dict(phi_deg=deg,
                        A1_area=get(A_pack,0,"area"), A1_cx=get(A_pack,0,"cx"), A1_cy=get(A_pack,0,"cy"),
                        A2_area=get(A_pack,1,"area"), A2_cx=get(A_pack,1,"cx"), A2_cy=get(A_pack,1,"cy"),
                        A3_area=get(A_pack,2,"area"), A3_cx=get(A_pack,2,"cx"), A3_cy=get(A_pack,2,"cy"),
                        B1_area=get(B_pack,0,"area"), B1_cx=get(B_pack,0,"cx"), B1_cy=get(B_pack,0,"cy"),
                        B2_area=get(B_pack,1,"area"), B2_cx=get(B_pack,1,"cx"), B2_cy=get(B_pack,1,"cy"),
                        C1_area=C1["area"], C1_cx=C1["cx"], C1_cy=C1["cy"],
                        Su_area=Su["area"], Su_cx=Su["cx"], Su_cy=Su["cy"],
                        sum_area=total_area)
        rows_area.append(area_row)

        # --- forces detailed ---
        Fz_comp = 0.0
        if len(A_pack)>1 and "A2" in pressures: Fz_comp -= pressures["A2"]*A_pack[1]["area"]
        if len(A_pack)>2 and "A3" in pressures: Fz_comp -= pressures["A3"]*A_pack[2]["area"]
        if len(B_pack)>1 and "B2" in pressures: Fz_comp -= pressures["B2"]*B_pack[1]["area"]
        if "C1" in pressures and not np.isnan(C1["area"]): Fz_comp -= pressures["C1"]*C1["area"]
        P_middle = variant["P_middle"]; P_C = pressures.get("C1", variant["P_C1_MP"])
        Fz_back = 0.0
        if total_area>0 and P_middle>0: Fz_back += P_middle*total_area
        Fz_back += (P_C - P_middle) * (math.pi * (variant["seal_radius"]**2))
        # lateral
        F_lat_vec = lateral_force_vector(variant, geom, phi, pressures, A_pack, B_pack, C1)
        Fx_lat, Fy_lat = float(F_lat_vec[0]), float(F_lat_vec[1])
        rows_force.append(dict(phi_deg=deg,
                               Fx_lat=Fx_lat, Fy_lat=Fy_lat,
                               Fz_comp=Fz_comp, Fz_back=Fz_back,
                               Fx_sum=Fx_lat, Fy_sum=Fy_lat, Fz_sum=Fz_comp+Fz_back))

        # --- ring moments (36 directions) ---
        O_list = ring_origins(phi, variant, geom, deg_step2=deg_step2)
        x_js = [j*deg_step2 for j in range(len(O_list))]
        m_top_list=[]; m_bot_list=[]; m_lat_list=[]; m_tot_list=[]
        for Oj in O_list:
            n_dir = radial_unit_from_Oj(Oj)    # direction "away from origin" is positive overturn
            m_top = top_thrust_moment_scalar(A_pack, B_pack, C1, pressures, Oj, n_dir)
            m_bot = bottom_thrust_moment_scalar(variant, Oj, n_dir, total_area, pressures)
            m_lat, _ = lateral_moment_scalar(variant, geom, phi, Oj, n_dir, pressures, A_pack, B_pack, C1)
            m_tot = m_top + m_bot + m_lat
            m_top_list.append(m_top); m_bot_list.append(m_bot); m_lat_list.append(m_lat); m_tot_list.append(m_tot)

        j_peak = int(np.argmax(m_tot_list))
        rows_worst.append(dict(phi_deg=deg, worst_dir_deg=x_js[j_peak], worst_moment_Nmm=float(m_tot_list[j_peak])))

        # optional plots
        if make_plots:
            plt.figure()
            plt.plot(x_js, m_top_list, label="top")
            plt.plot(x_js, m_bot_list, label="bottom")
            plt.plot(x_js, m_lat_list, label="lateral")
            plt.plot(x_js, m_tot_list, label="total")
            plt.xlabel("ring direction (deg from radial)")
            plt.ylabel("moment (N·mm)")
            plt.legend()
            fn = os.path.join(plots_dir, f"moments_phi_{int(deg):03d}.png")
            plt.savefig(fn, dpi=120)
            plt.close()

    # write CSVs
    df_area = pd.DataFrame(rows_area); df_area.to_csv(csv_areas, index=False)
    df_worst = pd.DataFrame(rows_worst); df_worst.to_csv(csv_worst, index=False)
    df_force = pd.DataFrame(rows_force); df_force.to_csv(csv_forces, index=False)

    sum_range = max(sums)-min(sums)
    print(f"[{variant_name}] sum_area min={min(sums):.9f}, max={max(sums):.9f}, range={sum_range:.3e}")
    return dict(outdir=outdir, csv_areas=csv_areas, csv_worst=csv_worst, csv_forces=csv_forces,
                df_area=df_area, df_worst=df_worst, df_force=df_force, sum_range=sum_range)

# ----------------------------- Run: generate CSVs -----------------------------
# You can switch variant_name to "R290". Plots are OFF by default to keep runtime small.
out_r32 = solve_and_export("R32", deg_step=10.0, deg_step2=10.0, make_plots=False, base_root="/mnt/data")
out_r290 = solve_and_export("R290", deg_step=10.0, deg_step2=10.0, make_plots=False, base_root="/mnt/data")

out_r32["outdir"], out_r290["outdir"]